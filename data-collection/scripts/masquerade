#!/usr/bin/env bash

helpFunction()
{
  echo ""
  echo "Usage: $0 -i /path/to/input/file -o /path/to/output/file -s /path/to/secrets/file"
  echo -e "\t-i Path to input file."
  echo -e "\t-o Path to output generated file."
  echo -e "\t-s Path to a file containing key/value secrets."
  echo -e "\t-f Force overwrite existing file at output path?"
  echo -e ""
  exit 1
}

FORCE_WRITE='false'

# Command line options
while getopts "i:o:s:f" opt
do
  case "$opt" in
    i ) INPUT_FILE="$OPTARG" ;;
    o ) OUTPUT_FILE="$OPTARG" ;;
    s ) SECRETS="$OPTARG" ;;
    f ) FORCE_WRITE='true' ;;
    ? ) helpFunction ;; # Print helpFunction in case parameter is non-existent
  esac
done

# Validate -i param:
# - input param is not missing
# - input file is file
if [ -z "$INPUT_FILE" ]; then
  echo "-i param is missing."
  helpFunction
elif [ ! -f $INPUT_FILE ]; then
  echo "$INPUT_FILE file not found."
  helpFunction
fi

# Validate -o param:
# - output param is not missing
# - output file exists and has specified a forced overwrite
if [ -z "$OUTPUT_FILE" ]; then
  echo "-o param is missing."
  helpFunction
elif [ -f $OUTPUT_FILE ] && [ $FORCE_WRITE == 'false' ]; then
  echo "File exists at path $OUTPUT_FILE"
  echo "Supply the -f flag to overwrite the output file."
  exit 1
fi

# Validate -s param:
# - secrets param is not missing
# - secrets is file
if [ -z "$SECRETS" ]; then
  echo "-s param is missing."
  helpFunction
elif [ ! -f $SECRETS ]; then
  echo "$SECRETS file not found."
  helpFunction
fi

# Create temporary directory
TEMP_DIR=$(mktemp -d -t secrets)

# Check if tmp dir was created
if [ ! "$TEMP_DIR" ] || [ ! -d "$TEMP_DIR" ]; then
  echo "Could not create temporary directory."
  exit 1
fi

# Deletes the temp directory
function cleanup {
  rm -rf "$TEMP_DIR"
}

# Register the cleanup function to be called on the EXIT signal
trap cleanup EXIT

## Create temporary file path
TEMP_FILE="$TEMP_DIR/$(basename "$INPUT_FILE")"

# Copy input file to temporary file
cp ${INPUT_FILE} ${TEMP_FILE}

# First pass: iterate replacing keys found in template with values found in secrets
while read line
do
  # Extract key/value pairs
	KEY=$(echo $line | cut -d= -f1)
	VALUE=$(echo $line | cut -d= -f2)
	# Use sed to replace keys with values
  # Note, accepts space surrounding key
	sed -i.bak -e "s/{{ *$KEY *}}/$VALUE/g" ${TEMP_FILE}
done < <(grep -Ev '^#' ${SECRETS})

# Second pass: clean-up missed variable brackets
while read line
do
	# Use sed to replace keys with values
	sed -i.bak -e "s/{{.*}}//g" ${TEMP_FILE}
done < <(grep -Ev '^#' ${TEMP_FILE})

# Move finished working file to ouput
mv ${TEMP_FILE} ${OUTPUT_FILE}
