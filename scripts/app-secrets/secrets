#!/usr/bin/env bash

helpFunction()
{
  echo ""
  echo "Usage: $0 -i /path/to/template/file.secret -o /path/to/output/dir -s /path/to/secrets/file"
  echo -e "\t-i Path to source code template. Note, the file must include '.secret' file extension"
  echo -e "\t-o Path to output rendered file. Note, the path must be to a directory and the program will remove the .secret file extension."
  echo -e "\t-s Path to a file containing your secrets. These secret keys must match those found in the INPUT_FILE file."
  echo -e "\t-f Overwrite existing file at output path."
  echo -e ""
  echo -e "secrets assu"
  exit 1 # Exit script after printing help
}

FORCE_WRITE='false'

# Command line options
while getopts "i:o:s:f" opt
do
  case "$opt" in
    i ) INPUT_FILE="$OPTARG" ;;
    o ) OUTPUT_DIR="$OPTARG" ;;
    s ) SECRETS="$OPTARG" ;;
    f ) FORCE_WRITE='true' ;;
    ? ) helpFunction ;; # Print helpFunction in case parameter is non-existent
  esac
done

# Validate -i param:
# - input file is not missing
# - input file is file
# - input file extension is 'secret'
if [ -z "$INPUT_FILE" ] || [ ! -f $INPUT_FILE ] || [ ! "${INPUT_FILE##*.}" == "secret" ]; then
  echo "$INPUT_FILE secret file not found."
  helpFunction
fi

# Validate -o param:
# - output directory is not missing
# - output directory is directory
if [ -z "$OUTPUT_DIR" ] || [ ! -d $OUTPUT_DIR ]; then
  echo "$OUTPUT_DIR directory not found."
  helpFunction
fi

# Derive output file path
OUTPUT_FILE_NAME=$(basename "${INPUT_FILE%.*}")
OUTPUT_FILE="$OUTPUT_DIR/$OUTPUT_FILE_NAME"

# Exit early if output file exists and user has not specified a forced overwrite
if [ -f $OUTPUT_FILE ] && [ $FORCE_WRITE == 'false' ]; then
  echo "File exists at path $OUTPUT_FILE"
  echo "Supply the -f flag to overwrite the output file."
  exit 1
fi

# Validate -s param:
# - secrets is not missing
# - secrets is file
if [ -z "$SECRETS" ] || [ ! -f $SECRETS ]; then
  echo "$SECRETS file not found."
  helpFunction
fi

# Create temporary directory
TEMP_DIR=$(mktemp -d -t secrets)

# Check if tmp dir was created
if [[ ! "$TEMP_DIR" || ! -d "$TEMP_DIR" ]]; then
  echo "Could not create temporary directory."
  exit 1
fi

# Deletes the temp directory
function cleanup {
  rm -rf "$TEMP_DIR"
}

# Register the cleanup function to be called on the EXIT signal
trap cleanup EXIT

## Create temporary file path
TEMP_FILE="$TEMP_DIR/$OUTPUT_FILE_NAME"
# Copy input file to temporary file
cp ${INPUT_FILE} ${TEMP_FILE}

# First pass: iterate replacing keys found in template with values found in secrets
while read line
do
  # Extract key/value pairs
	KEY=$(echo $line | cut -d= -f1)
	VALUE=$(echo $line | cut -d= -f2)
	# Use sed to replace keys with values
  # Note, accepts space surrounding key
	sed -i.bak -e "s/{{ *$KEY *}}/$VALUE/g" ${TEMP_FILE}
done < <(grep -Ev '^#' ${SECRETS})

# Second pass: clean-up missed variable brackets
while read line
do
	# Use sed to replace keys with values
	sed -i.bak -e "s/{{.*}}//g" ${TEMP_FILE}
done < <(grep -Ev '^#' ${TEMP_FILE})

# Move finished working file to ouput
mv ${TEMP_FILE} ${OUTPUT_FILE}
